<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Poligoni: costruisci e gioca</title>
  <style>
    :root{
      --bg:#f2f2f2;
      --card:#ffffff;
      --ink:#1f2937;
      --muted:#6b7280;
      --good:#16a34a;
      --bad:#dc2626;
      --accent:#2563eb;
      --soft:#f8fafc;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--ink);
      display:flex;
      justify-content:center;
      padding:18px;
    }
    .wrap{ width:min(1280px, 100%); }

    .topbar{
      background:var(--card);
      border-radius:16px;
      box-shadow:0 6px 18px rgba(0,0,0,.08);
      padding:14px 16px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .titleRow{
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    .titleRow h1{
      margin:0;
      font-size:18px;
      font-weight:900;
    }
    .creditTop{
      font-size:12px;
      color:var(--muted);
      font-weight:900;
      white-space:nowrap;
    }
    .subtitle{
      margin:6px 0 0;
      font-size:13px;
      color:var(--muted);
      font-weight:800;
    }

    /* BOTTONI (sotto canvas) */
    .actionsUnder{
      margin-top:12px;
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:space-between;
    }

    .btn{
      border:0;
      border-radius:12px;
      padding:10px 12px;
      font-weight:900;
      cursor:pointer;
      background:var(--accent);
      color:white;
      box-shadow:0 6px 14px rgba(37,99,235,.18);
      user-select:none;
    }
    .btn.secondary{
      background:#111827;
      box-shadow:0 6px 14px rgba(0,0,0,.18);
    }
    .btn.ghost{
      background:#e5e7eb;
      color:#111827;
      box-shadow:none;
    }
    .btn:disabled{
      opacity:.55;
      cursor:not-allowed;
      box-shadow:none;
      transform:none !important;
    }
    .btn:active{ transform:translateY(1px); }

    /* Effetto game (pulse) */
    .pulse{
      background: linear-gradient(90deg, #22c55e, #16a34a) !important;
      color:#fff !important;
      box-shadow: 0 10px 22px rgba(22,163,74,.25) !important;
      animation: pulse 1.2s infinite;
    }
    @keyframes pulse{
      0% { transform: scale(1); }
      50%{ transform: scale(1.03); }
      100%{ transform: scale(1); }
    }

    /* NEXT: pulse quando sbloccato */
    #nextBtn.nextReady{
      background: linear-gradient(90deg, #22c55e, #16a34a);
      color:#fff;
      box-shadow: 0 10px 22px rgba(22,163,74,.25);
      animation: pulse 1.2s infinite;
    }
    #nextBtn:disabled{
      background:#e5e7eb !important;
      color:#6b7280 !important;
      animation:none !important;
      box-shadow:none !important;
    }

    /* 3 colonne */
    .main{
      margin-top:14px;
      display:grid;
      grid-template-columns: 320px 1fr 380px;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 1100px){
      .main{ grid-template-columns: 1fr; }
      .actionsUnder{ justify-content:flex-start; }
    }

    .panel{
      background:var(--card);
      border-radius:16px;
      box-shadow:0 6px 18px rgba(0,0,0,.08);
      padding:14px;
    }

    /* Menu */
    .menu h2{ margin:0 0 10px; font-size:16px; }
    .menu .group{ margin-top:12px; }
    .menu .groupTitle{
      font-size:12px;
      font-weight:900;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.04em;
      margin:0 0 8px;
    }
    .menu button.item{
      width:100%;
      text-align:left;
      border:1px solid rgba(0,0,0,.06);
      background:var(--soft);
      padding:10px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
      margin-bottom:8px;
    }
    .menu button.item small{
      display:block;
      font-weight:800;
      color:var(--muted);
      margin-top:2px;
    }
    .menu button.item.active{
      background:#eef2ff;
      border-color:rgba(37,99,235,.25);
    }
    .menu button.item:disabled{
      opacity:.6;
      cursor:not-allowed;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      background:#f3f4f6;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(0,0,0,.06);
      font-weight:900;
      white-space:nowrap;
    }

    /* Canvas */
    .stage{
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,.06);
      background:#fff;
    }
    canvas{ width:100%; height:auto; display:block; background:#fff; touch-action:none; }

    /* Feedback + teoria (colonna destra) */
    .info{
      background:var(--soft);
      border:1px solid rgba(0,0,0,.06);
      border-radius:14px;
      padding:12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .statusLeft{
      display:flex;
      gap:10px;
      align-items:flex-start;
      min-height:36px;
      flex:1 1 240px;
    }
    .smile{
      width:34px;height:34px;
      border-radius:50%;
      display:grid;
      place-items:center;
      font-size:18px;
      background:#e5e7eb;
      flex:0 0 auto;
    }
    .msg{
      font-weight:900;
      font-size:15px;
      line-height:1.15;
    }
    .msg small{
      display:block;
      font-weight:800;
      color:var(--muted);
      margin-top:4px;
      font-size:13px;
    }
    .ok .smile{ background:#dcfce7; }
    .ok .msg{ color:var(--good); }
    .no .smile{ background:#fee2e2; }
    .no .msg{ color:var(--bad); }

    .controls{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .control{
      background:var(--soft);
      border:1px solid rgba(0,0,0,.06);
      border-radius:12px;
      padding:10px;
      display:flex;
      align-items:center;
      gap:10px;
      flex: 1 1 280px;
      min-width:280px;
    }
    .control label{
      font-weight:900;
      font-size:13px;
      color:var(--ink);
      white-space:nowrap;
    }
    .quizRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      width:100%;
    }
    .quizRow .btn{ flex:1 1 110px; min-width:110px; }

    .theory h2{ margin:0 0 8px; font-size:16px; }
    .theory p, .theory li{ font-size:14px; }
    .theory .muted{ color:var(--muted); }

    .awardBox{
      margin-top:12px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,.06);
      background:#fff;
      padding:12px;
    }
    .awardBox h3{
      margin:0 0 6px;
      font-size:15px;
      font-weight:1000;
    }
    .awardBox p{ margin:0; color:var(--muted); font-weight:800; font-size:13px; }

    input[type="text"], input[type="number"]{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(0,0,0,.12);
      font-weight:900;
      font-size:14px;
      background:#fff;
    }

    /* =========================
       ATTESTATO SOLO TESTO (stampa)
       ========================= */
    #certificatePrint{
      display:none;
      padding:28px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#111827;
    }
    #certificatePrint .cert{
      border:10px solid #111827;
      border-radius:18px;
      padding:34px;
      min-height:740px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      text-align:center;
      background:#fff;
    }
    #certificatePrint h1{
      margin:0;
      font-size:42px;
      font-weight:1000;
      letter-spacing:.6px;
    }
    #certificatePrint h2{
      margin:10px 0 0;
      font-size:22px;
      font-weight:1000;
      color:#2563eb;
    }
    #certificatePrint .name{
      margin:22px auto 0;
      font-size:32px;
      font-weight:1000;
      border-bottom:3px dashed rgba(0,0,0,.25);
      padding-bottom:10px;
      width:min(560px, 86%);
    }
    #certificatePrint .epic{
      margin:24px auto 0;
      width:min(860px, 94%);
      font-size:18px;
      line-height:1.7;
      font-weight:900;
      color:#111827;
    }
    #certificatePrint .epic .mut{
      color:#374151;
      font-weight:800;
    }
    #certificatePrint .footer{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:14px;
      margin-top:30px;
      font-weight:1000;
    }
    #certificatePrint .sign{
      width:45%;
      border-top:2px solid rgba(0,0,0,.3);
      padding-top:10px;
      text-align:center;
    }
    @media print{
      body{ background:#fff; padding:0; }
      .wrap{ display:none !important; }
      #certificatePrint{ display:block !important; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <div class="titleRow">
          <h1>Poligoni ‚Äì costruisci e gioca</h1>
          <div class="creditTop">(creato dal Maestro Lino Centonze - IC Tempesta Galateo Lecce)</div>
        </div>
        <div class="subtitle">
          Costruisci, conta, misura‚Ä¶ e alla fine diventa Campione dei Poligoni!
        </div>
      </div>
    </div>

    <div class="main">
      <!-- Colonna 1: menu -->
      <div class="panel menu">
        <h2>üìö Livelli</h2>
        <div id="menuArea"></div>
      </div>

      <!-- Colonna 2: canvas + pulsanti sotto -->
      <div class="panel">
        <div class="stage">
          <canvas id="cv" width="980" height="620"></canvas>
        </div>

        <!-- Barra bottoni: in premio finale resta solo griglie + stampa -->
        <div class="actionsUnder" id="toolbar">
          <button class="btn ghost" id="nextBtn">Vai al livello successivo ‚Üí</button>
          <button class="btn secondary" id="helpBtn">AIUTO</button>
          <button class="btn ghost" id="grid1">Griglia 1 cm</button>
          <button class="btn ghost" id="grid05">Griglia 0,5 cm</button>
          <button class="btn pulse" id="printBtn" style="display:none;">Stampa attestato üñ®Ô∏è</button>
          <button class="btn" id="resetBtn">Ricomincia</button>
        </div>
      </div>

      <!-- Colonna 3: feedback + teoria + controlli -->
      <div class="panel">
        <div id="status" class="info">
          <div class="statusLeft">
            <div id="smile" class="smile">üôÇ</div>
            <div class="msg" id="msg">
              Inizia dal livello 1!
              <small>Premi <span class="kbd">AIUTO</span> se ti serve.</small>
            </div>
          </div>

          <div style="font-weight:900;color:var(--muted);">
            Griglia: <span class="kbd" id="gridLabel">1 cm</span>
          </div>
        </div>

        <div class="controls" id="controls"></div>

        <div class="panel theory" style="margin-top:14px;">
          <h2 id="theoryTitle">üß† Spiegazione</h2>
          <div id="theoryBody"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ATTESTATO (solo stampa) -->
  <div id="certificatePrint">
    <div class="cert">
      <div>
        <h1>ATTESTATO</h1>
        <h2>Campione dei Poligoni</h2>

        <div class="epic mut">
          Si certifica che l‚Äôalunno/a
        </div>

        <div class="name" id="certName">________________________</div>

        <div class="epic">
          <span class="mut">ha completato tutte le sfide del percorso</span>
          <b>‚ÄúPoligoni ‚Äì costruisci e gioca‚Äù</b>.
          <br><br>
          Oggi hai fatto qualcosa che fanno i veri geometri: <b>hai osservato, contato, misurato e costruito</b>.
          Hai allenato gli occhi a vedere le forme, la mente a ragionare con precisione e le mani a muovere i punti
          con attenzione.
          <br><br>
          Ogni lato controllato √® stato un passo. Ogni figura completata √® stata una piccola vittoria.
          E quando qualcuno ti chieder√† ‚Äúcom‚Äô√® possibile?‚Äù, tu potrai rispondere con orgoglio:
          <br><br>
          <b>‚ÄúNon √® magia: √® matematica!‚Äù</b>
        </div>
      </div>

      <div class="footer">
        <div class="sign">Data: ____________</div>
        <div class="sign">Maestro Lino Centonze</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const DEV_UNLOCK_ALL = false;

  const POLY_NAMES = { 5:"Pentagono", 6:"Esagono", 7:"Ettagono", 8:"Ottagono", 9:"Ennagono", 10:"Decagono" };

  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');

  const statusEl = document.getElementById('status');
  const smileEl  = document.getElementById('smile');
  const msgEl    = document.getElementById('msg');

  const resetBtn = document.getElementById('resetBtn');
  const helpBtn  = document.getElementById('helpBtn');
  const nextBtn  = document.getElementById('nextBtn');
  const printBtn = document.getElementById('printBtn');
  const toolbar  = document.getElementById('toolbar');

  const controlsWrap = document.getElementById('controls');
  const menuArea = document.getElementById('menuArea');

  const grid1Btn = document.getElementById('grid1');
  const grid05Btn = document.getElementById('grid05');
  const gridLabel = document.getElementById('gridLabel');

  const theoryTitle = document.getElementById('theoryTitle');
  const theoryBody  = document.getElementById('theoryBody');

  /* Griglia */
  const CM_TO_PX = 96 / 2.54;
  let GRID_CM = parseFloat(localStorage.getItem("grid_cm") || "1");
  let GRID = GRID_CM * CM_TO_PX;

  const TOL_CM = 0.35; // interna (non mostrata)
  let TOL = TOL_CM * CM_TO_PX;

  function setGridCm(v){
    GRID_CM = v;
    localStorage.setItem("grid_cm", String(v));
    GRID = GRID_CM * CM_TO_PX;
    TOL = TOL_CM * CM_TO_PX;
    gridLabel.textContent = (GRID_CM === 1 ? "1 cm" : "0,5 cm");
  }
  setGridCm(GRID_CM);

  const dist = (p,q) => Math.hypot(p.x-q.x, p.y-q.y);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const snap = (v) => Math.round(v / GRID) * GRID;
  const snapIfNeeded = (v, enabled) => enabled ? snap(v) : v;

  function snapMajorY(y){
    const major = GRID * 5;
    return Math.round(y / major) * major;
  }

  function lenCm(px){ return (px / GRID) * GRID_CM; }
  function fmtNum1(cm){
    const r = Math.round(cm * 10) / 10;
    return String(r).replace('.', ',');
  }
  function fmtCm(px){ return fmtNum1(lenCm(px)) + " cm"; }

  function hintToTargetCm(actualCm, targetCm){
    const d = targetCm - actualCm;
    const step = GRID_CM;
    const dd = Math.round(d / step) * step;
    if(Math.abs(dd) < 1e-9) return "";
    const txt = fmtNum1(Math.abs(dd)) + " cm";
    return (dd > 0) ? ("Ti manca " + txt) : ("Togli " + txt);
  }

  function setStatus(state, main, sub){
    statusEl.classList.remove('ok','no');
    if(state === 'ok'){ statusEl.classList.add('ok'); smileEl.textContent="üòÑ"; }
    else if(state === 'no'){ statusEl.classList.add('no'); smileEl.textContent="üòï"; }
    else { smileEl.textContent="üôÇ"; }
    msgEl.innerHTML = `${main}${sub ? `<small>${sub}</small>` : ''}`;
  }

  function setTheory(title, html){
    theoryTitle.textContent = title;
    theoryBody.innerHTML = html;
  }

  function pointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const y = (evt.clientY - rect.top)  * (canvas.height / rect.height);
    return {x,y};
  }
  function hitPoint(p, x, y){
    return Math.hypot(p.x-x, p.y-y) <= (p.r||12) + 10;
  }

  /* Toolbar: nel premio finale SOLO griglie + stampa (come screenshot) */
  function applyBonusToolbar(isBonus){
    nextBtn.style.display  = isBonus ? "none" : "";
    helpBtn.style.display  = isBonus ? "none" : "";
    resetBtn.style.display = isBonus ? "none" : "";
    printBtn.style.display = isBonus ? "" : "none";

    grid1Btn.style.display  = "";
    grid05Btn.style.display = "";

    toolbar.style.justifyContent = isBonus ? "flex-start" : "space-between";
  }

  /* Progressione */
  const STORE_KEY = "poly_game_progress_final_v1";
  const progress = JSON.parse(localStorage.getItem(STORE_KEY) || "{}");
  function isCompleted(id){ return !!progress[id]; }
  function markCompleted(id){
    progress[id] = true;
    localStorage.setItem(STORE_KEY, JSON.stringify(progress));
  }

  const LEVELS = [
    { id:"tri_equil", label:"Triangolo equilatero", sub:"C libero + calamita", group:"1¬∞ livello ‚Äî Triangoli" },
    { id:"tri_isos",  label:"Triangolo isoscele",   sub:"passa se AC=BC",      group:"1¬∞ livello ‚Äî Triangoli" },
    { id:"tri_right_generic", label:"Triangolo rettangolo (generico)", sub:"retto in A o B o C", group:"1¬∞ livello ‚Äî Triangoli" },

    { id:"tri_right_talete",  label:"Talete", sub:"retto in C (cerchio)", group:"2¬∞ livello ‚Äî Talete" },

    { id:"quad_square", label:"Quadrato",   sub:"tutti i lati = AB", group:"2¬∞ livello ‚Äî Quadrilateri" },
    { id:"quad_rect",   label:"Rettangolo", sub:"AB=CD e BC=DA",     group:"2¬∞ livello ‚Äî Quadrilateri" },

    { id:"quiz_5",  label:"Pentagono (gioco)", sub:"conta + misura", group:"3¬∞ ‚Üí 8¬∞ livello ‚Äî Poligoni (gioco)" },
    { id:"quiz_6",  label:"Esagono (gioco)",   sub:"conta + misura", group:"3¬∞ ‚Üí 8¬∞ livello ‚Äî Poligoni (gioco)" },
    { id:"quiz_7",  label:"Ettagono (gioco)",  sub:"conta + misura", group:"3¬∞ ‚Üí 8¬∞ livello ‚Äî Poligoni (gioco)" },
    { id:"quiz_8",  label:"Ottagono (gioco)",  sub:"conta + misura", group:"3¬∞ ‚Üí 8¬∞ livello ‚Äî Poligoni (gioco)" },
    { id:"quiz_9",  label:"Ennagono (gioco)",  sub:"conta + misura", group:"3¬∞ ‚Üí 8¬∞ livello ‚Äî Poligoni (gioco)" },
    { id:"quiz_10", label:"Decagono (gioco)",  sub:"conta + misura", group:"3¬∞ ‚Üí 8¬∞ livello ‚Äî Poligoni (gioco)" },

    { id:"bonus_free", label:"üéÅ Premio finale", sub:"crea il tuo poligono + attestato", group:"Premio" },
  ];

  function getIndexById(id){ return LEVELS.findIndex(l => l.id === id); }

  function allCoreLevelsCompleted(){
    const core = LEVELS.filter(l => l.id !== "bonus_free").map(l => l.id);
    return core.every(id => isCompleted(id));
  }

  function isUnlocked(levelId){
    if(DEV_UNLOCK_ALL) return true;
    if(levelId === LEVELS[0].id) return true;

    if(levelId === "bonus_free"){
      return allCoreLevelsCompleted();
    }
    const idx = getIndexById(levelId);
    const prev = LEVELS[idx-1]?.id;
    return prev ? isCompleted(prev) : false;
  }

  let mode = LEVELS[0].id;
  let showHelp = false;
  let lastOk = false;

  const A = { x: 0, y: 0, r: 10, label: 'A' };
  const B = { x: 0, y: 0, r: 10, label: 'B' };
  let P = { x: 0, y: 0, r: 12, label:'C' };

  const BASE_AB_CM = 8;

  let quiz = {
    stage: "count",
    n: 5,
    sideCm: 4,
    revealK: 0,
    revealTimer: null,
    center: {x:0,y:0},
    radiusPx: 0,
    angle0: 0,
    pts: []
  };

  let bonus = { sides: 7, radiusCm: 5, name: "" };

  function clearControls(){ controlsWrap.innerHTML = ""; }

  function addQuizButtons(title, options, onPick){
    const box = document.createElement('div');
    box.className = 'control';
    box.style.flex = "1 1 100%";
    box.innerHTML = `<div style="font-weight:900">${title}</div><div class="quizRow" id="qrow"></div>`;
    controlsWrap.appendChild(box);
    const row = box.querySelector("#qrow");

    options.forEach(v => {
      const b = document.createElement('button');
      b.className = "btn ghost";
      b.textContent = String(v);
      b.addEventListener('click', () => onPick(v));
      row.appendChild(b);
    });
  }

  function addNumberControl(label, min, max, value, onChange){
    const box = document.createElement('div');
    box.className = 'control';
    box.innerHTML = `
      <label>${label}</label>
      <input type="number" min="${min}" max="${max}" value="${value}">
      <span class="kbd">(${min}‚Äì${max})</span>
    `;
    const input = box.querySelector("input");
    input.addEventListener("input", () => {
      let v = parseInt(input.value || value, 10);
      v = clamp(v, min, max);
      input.value = v;
      onChange(v);
    });
    controlsWrap.appendChild(box);
  }

  function addTextControl(label, placeholder, value, onChange){
    const box = document.createElement('div');
    box.className = 'control';
    box.style.flex = "1 1 100%";
    box.innerHTML = `<label>${label}</label><input type="text" placeholder="${placeholder}" value="${value}">`;
    const input = box.querySelector("input");
    input.addEventListener("input", () => onChange(input.value));
    controlsWrap.appendChild(box);
  }

  function stopReveal(){
    if(quiz.revealTimer){
      clearInterval(quiz.revealTimer);
      quiz.revealTimer = null;
    }
  }
  function startReveal(){
    stopReveal();
    quiz.revealK = 0;
    quiz.revealTimer = setInterval(() => {
      quiz.revealK = Math.min(quiz.n, quiz.revealK + 1);
      render();
      if(quiz.revealK >= quiz.n) stopReveal();
    }, 220);
  }

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
  }

  function getEquilateralTargets(){
    const R = dist(A,B);
    const M = { x:(A.x+B.x)/2, y:(A.y+B.y)/2 };
    const h = Math.sqrt(Math.max(0, R*R - (R/2)*(R/2)));
    const ux = (B.x - A.x)/R, uy = (B.y - A.y)/R;
    const px = -uy, py = ux;
    return [
      { x: M.x + px*h, y: M.y + py*h },
      { x: M.x - px*h, y: M.y - py*h }
    ];
  }

  function regularPolygon(n, center, radius, angle0){
    const pts = [];
    for(let i=0;i<n;i++){
      const a = angle0 + i*(Math.PI*2/n);
      pts.push({x:center.x + Math.cos(a)*radius, y:center.y + Math.sin(a)*radius});
    }
    return pts;
  }

  function radiusFromSideCm(n, sideCm){
    return sideCm / (2 * Math.sin(Math.PI / n));
  }

  function angleForHorizontalBase(n){
    return (Math.PI/2) - (Math.PI/n);
  }

  function drawGrid(){
    ctx.save();
    for(let x=0; x<=canvas.width; x+=GRID){
      const major = Math.round(x/GRID) % 5 === 0;
      ctx.beginPath();
      ctx.moveTo(x,0); ctx.lineTo(x,canvas.height);
      ctx.strokeStyle = major ? "rgba(148,163,184,.45)" : "rgba(203,213,225,.28)";
      ctx.lineWidth = major ? 1.6 : 1;
      ctx.stroke();
    }
    for(let y=0; y<=canvas.height; y+=GRID){
      const major = Math.round(y/GRID) % 5 === 0;
      ctx.beginPath();
      ctx.moveTo(0,y); ctx.lineTo(canvas.width,y);
      ctx.strokeStyle = major ? "rgba(148,163,184,.45)" : "rgba(203,213,225,.28)";
      ctx.lineWidth = major ? 1.6 : 1;
      ctx.stroke();
    }
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawLengthLabel(p, q, mainText, hintText=""){
    const mx = (p.x + q.x) / 2;
    const my = (p.y + q.y) / 2;
    const ang = Math.atan2(q.y - p.y, q.x - p.x);
    const nx = -Math.sin(ang), ny = Math.cos(ang);
    const offset = 18;
    const lx = mx + nx * offset;
    const ly = my + ny * offset;

    ctx.save();
    ctx.translate(lx, ly);
    let rot = ang;
    if(rot > Math.PI/2 || rot < -Math.PI/2) rot += Math.PI;
    ctx.rotate(rot);

    const padX = 8;
    ctx.font = "900 13px system-ui, Arial";
    const w1 = ctx.measureText(mainText).width;
    let w = w1;
    const hasHint = !!hintText;

    let w2 = 0;
    if(hasHint){
      ctx.font = "900 12px system-ui, Arial";
      w2 = ctx.measureText(hintText).width;
      w = Math.max(w1, w2);
    }

    const boxW = w + padX*2;
    const boxH = hasHint ? 38 : 22;
    const topY = hasHint ? -24 : -14;

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.strokeStyle = "rgba(0,0,0,.12)";
    ctx.lineWidth = 1;
    roundRect(ctx, -boxW/2, topY, boxW, boxH, 10);
    ctx.fill();
    ctx.stroke();

    ctx.font = "900 13px system-ui, Arial";
    ctx.fillStyle = "rgba(17,24,39,.92)";
    ctx.fillText(mainText, -w1/2, hasHint ? -6 : 2);

    if(hasHint){
      ctx.font = "900 12px system-ui, Arial";
      ctx.fillStyle = "rgba(220,38,38,.92)";
      ctx.fillText(hintText, -w2/2, 12);
    }
    ctx.restore();
  }

  function drawPoint(p, color, ring=false){
    ctx.save();
    if(ring){
      ctx.lineWidth=4;
      ctx.strokeStyle="rgba(37,99,235,.30)";
      ctx.beginPath(); ctx.arc(p.x,p.y,(p.r||12)+8,0,Math.PI*2); ctx.stroke();
    }
    ctx.fillStyle=color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r||12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#0f172a";
    ctx.font="900 16px system-ui, Arial";
    ctx.fillText(p.label||'', p.x + 14, p.y + 6);
    ctx.restore();
  }

  function drawSegment(p,q, w=6, color="rgba(17,24,39,.85)"){
    ctx.save();
    ctx.lineWidth=w; ctx.strokeStyle=color; ctx.lineCap="round";
    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
    ctx.restore();
  }

  function drawCircle(c, r, dash=true, color="rgba(37,99,235,.55)"){
    ctx.save();
    ctx.lineWidth=2;
    if(dash) ctx.setLineDash([8,8]);
    ctx.strokeStyle=color;
    ctx.beginPath(); ctx.arc(c.x,c.y,r,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawSilhouette(points){
    ctx.save();
    ctx.lineWidth = 5;
    ctx.strokeStyle = "rgba(148,163,184,.70)";
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  function drawRevealedEdges(points, k){
    ctx.save();
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(34,197,94,.80)";
    ctx.lineCap = "round";
    for(let i=0;i<k;i++){
      const a = points[i];
      const b = points[(i+1)%points.length];
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();
  }

  function renderMenu(){
    menuArea.innerHTML = "";
    const groups = {};
    LEVELS.forEach((lvl) => {
      if(!groups[lvl.group]) groups[lvl.group] = [];
      groups[lvl.group].push(lvl);
    });

    Object.keys(groups).forEach(groupName => {
      const g = document.createElement('div');
      g.className = "group";
      g.innerHTML = `<div class="groupTitle">${groupName}</div>`;

      groups[groupName].forEach(item => {
        const unlocked = isUnlocked(item.id);
        const btn = document.createElement('button');
        btn.className = "item" + (item.id === mode ? " active" : "");
        btn.innerHTML = `${item.label}${unlocked ? "" : " <span class='kbd'>BLOCCATO</span>"}<small>${item.sub}</small>`;
        btn.disabled = !unlocked;
        btn.addEventListener('click', () => setMode(item.id));
        g.appendChild(btn);
      });

      menuArea.appendChild(g);
    });
  }

  function updateNextButton(){
    const idx = getIndexById(mode);
    const hasNext = idx < LEVELS.length - 1;

    if(!hasNext){
      nextBtn.disabled = true;
      nextBtn.textContent = "Fine!";
      nextBtn.classList.remove("nextReady");
      return;
    }

    const nextId = LEVELS[idx+1].id;
    const canGo = isUnlocked(nextId);

    nextBtn.disabled = !canGo;
    nextBtn.textContent = canGo ? "Vai al livello successivo ‚Üí" : "Completa questo livello per andare avanti";
    nextBtn.classList.toggle("nextReady", !nextBtn.disabled);
  }

  function setMode(newMode){
    mode = newMode;
    showHelp = false;
    helpBtn.textContent = "AIUTO";
    resetLevel(true);
    renderMenu();
    updateNextButton();
    applyBonusToolbar(mode === "bonus_free");
  }

  function resetLevel(full){
    stopReveal();
    clearControls();
    lastOk = false;

    if(full){
      A.x = snap(260);
      A.y = snap(400);
      const steps = (BASE_AB_CM / GRID_CM);
      B.x = A.x + steps * GRID;
      B.y = A.y;
      P = { x: snap((A.x+B.x)/2), y: snap(220), r: 12, label:'C' };
    }

    if(mode === "tri_equil"){
      P.label = "C";
      setStatus("neutral","Triangolo equilatero","Rendi AB=AC=BC. C si aggancia al punto giusto.");
      setTheory("üß† Triangolo equilatero",
        `<p class="muted"><b>AB = AC = BC</b></p>
         <ol>
           <li>Premi AIUTO per vedere i cerchi del compasso.</li>
           <li>Trascina C: quando sei vicino, si aggancia!</li>
         </ol>`
      );
      render(); check(); return;
    }

    if(mode === "tri_isos"){
      P.label = "C";
      setStatus("neutral","Triangolo isoscele","Devi fare AC e BC uguali.");
      setTheory("üß† Triangolo isoscele", `<p class="muted">√à isoscele quando <b>AC = BC</b>.</p>`);
      render(); check(); return;
    }

    if(mode === "tri_right_generic"){
      P.label = "C";
      setStatus("neutral","Triangolo rettangolo (generico)","Va bene retto in A o in B o in C.");
      setTheory("üß† Triangolo rettangolo", `<p class="muted">√à rettangolo se <b>un angolo</b> √® di 90¬∞.</p>`);
      render(); check(); return;
    }

    if(mode === "tri_right_talete"){
      P.label = "C";
      setStatus("neutral","Talete","C deve stare sul cerchio (premi AIUTO).");
      setTheory("üß† Talete", `<p class="muted">Se <b>AB</b> √® un diametro, ogni punto <b>C</b> sul cerchio crea un angolo retto in <b>C</b>.</p>`);
      render(); check(); return;
    }

    if(mode === "quad_square"){
      P.label = "C";
      setStatus("neutral","Quadrato","Tutti i lati devono essere uguali ad AB.");
      setTheory("üß† Quadrato", `<p class="muted"><b>AB = BC = CD = DA</b></p>`);
      render(); check(); return;
    }

    if(mode === "quad_rect"){
      P.label = "C";
      setStatus("neutral","Rettangolo","AB = CD e BC = DA.");
      setTheory("üß† Rettangolo", `<p class="muted"><b>AB = CD</b> e <b>BC = DA</b></p>`);
      render(); check(); return;
    }

    if(mode.startsWith("quiz_")){
      quiz.stage = "count";
      quiz.revealK = 0;
      quiz.n = parseInt(mode.split("_")[1],10);

      const sideMap = {5:4,6:4,7:3,8:3,9:2,10:2};
      quiz.sideCm = sideMap[quiz.n] || 3;

      quiz.center = { x: snap(520), y: snap(320) };

      const rCm = radiusFromSideCm(quiz.n, quiz.sideCm);
      quiz.radiusPx = (rCm / GRID_CM) * GRID;

      quiz.angle0 = angleForHorizontalBase(quiz.n);

      const baseYtarget = snapMajorY(snap(420));
      const k = Math.cos(Math.PI / quiz.n);
      quiz.center.y = baseYtarget - k * quiz.radiusPx;

      quiz.pts = regularPolygon(quiz.n, quiz.center, quiz.radiusPx, quiz.angle0);

      const nm = POLY_NAMES[quiz.n] || (quiz.n + "-gono");
      setStatus("neutral", `${nm} (gioco)`, "Prima: conta i lati. Poi: misura la base.");
      setTheory("üéÆ Poligoni (gioco)",
        `<ol>
          <li><b>Conta i lati</b> e scegli il bottone giusto.</li>
          <li>Poi <b>misura la base</b> contando i quadretti (la base √® orizzontale).</li>
        </ol>`
      );

      buildQuizUI();
      render();
      return;
    }

    if(mode === "bonus_free"){
      setStatus("neutral","üéÅ Premio finale","Sei arrivato fin qui: ora crea poligoni come un vero geometra!");
      setTheory("üéÅ Premio finale",
        `<div class="awardBox">
           <h3>üèÜ Complimenti!</h3>
           <p>
             Hai completato tutti i livelli! Ora puoi scegliere quanti lati vuoi e far apparire il poligono.
             Prova numeri diversi e osserva come cambia la figura: sembra magia‚Ä¶ ma √® matematica!
           </p>
         </div>`
      );

      clearControls();
      addNumberControl("Quanti lati vuoi? (3‚Äì20)", 3, 20, bonus.sides, (v) => { bonus.sides = v; render(); });
      addNumberControl("Raggio (in cm) (2‚Äì10)", 2, 10, bonus.radiusCm, (v) => { bonus.radiusCm = v; render(); });
      addTextControl("Nome e cognome (per l‚Äôattestato)", "Es. Mario Rossi", bonus.name, (v) => { bonus.name = v; });

      render();
      return;
    }
  }

  function buildQuizUI(){
    clearControls();

    if(quiz.stage === "count"){
      const opts = [quiz.n-1, quiz.n, quiz.n+1].filter(v => v>=3);
      shuffle(opts);
      addQuizButtons("Quanti lati ha questa figura?", opts, (v) => {
        const diff = Math.abs(v - quiz.n);
        if(diff === 0){
          quiz.stage = "side";
          setStatus("ok","Bravo! üéâ","Ora misura la base (in cm).");
          startReveal();
          buildQuizUI();
        } else if(diff === 1){
          setStatus("no","Ci sei quasi!","Sei vicinissimo: riconta i lati.");
        } else {
          setStatus("no","Conta bene!","Riconta lentamente i lati della figura.");
        }
      });
      return;
    }

    if(quiz.stage === "side"){
      const s = quiz.sideCm;
      const opts = [Math.max(1,s-1), s, s+1];
      shuffle(opts);
      addQuizButtons("Quanto misura la base? (in cm)", opts, (v) => {
        const diff = Math.abs(v - s);
        if(diff === 0){
          quiz.stage = "done";
          lastOk = true;
          stopReveal();
          quiz.revealK = quiz.n;
          setStatus("ok","Bravo! üéâ","Livello completato. Vai avanti!");

          if(!isCompleted(mode)){
            markCompleted(mode);
            renderMenu();
            updateNextButton();
          }
          clearControls();
        } else if(diff === 1){
          setStatus("no","Ci sei quasi!","Sei vicino: conta bene i quadretti.");
        } else {
          setStatus("no","Conta bene!","Conta i quadretti della base (√® orizzontale).");
        }
        render();
      });
      return;
    }
  }

  function drawAB(){
    drawSegment(A,B,6,"rgba(17,24,39,.85)");
    drawPoint(A,"rgba(17,24,39,.95)");
    drawPoint(B,"rgba(17,24,39,.95)");
    drawLengthLabel(A,B,"AB = " + fmtCm(dist(A,B)));
  }

  function render(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawGrid();

    if(mode.startsWith("quiz_")){
      const pts = quiz.pts;
      drawSilhouette(pts);
      drawRevealedEdges(pts, quiz.revealK);

      const a = pts[0], b = pts[1];
      if(quiz.stage === "side" || quiz.stage === "done"){
        ctx.save();
        ctx.lineWidth = 8;
        ctx.strokeStyle = "rgba(37,99,235,.85)";
        ctx.lineCap = "round";
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
        ctx.restore();

        drawLengthLabel(a,b,"Base = ?", "");
        if(showHelp){
          drawLengthLabel(a,b,"Base = " + fmtCm(dist(a,b)));
        }
      }
      return;
    }

    if(mode === "bonus_free"){
      const O = { x: snap(520), y: snap(320) };
      const rPx = (bonus.radiusCm / GRID_CM) * GRID;
      const angle0 = angleForHorizontalBase(bonus.sides);
      const pts = regularPolygon(bonus.sides, O, rPx, angle0);

      ctx.save();
      ctx.lineWidth=5;
      ctx.strokeStyle="rgba(34,197,94,.80)";
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath(); ctx.stroke();
      ctx.restore();

      const sidePx = dist(pts[0], pts[1]);
      drawLengthLabel(pts[0], pts[1], "Lato = " + fmtCm(sidePx));
      return;
    }

    drawAB();
    const ABpx = dist(A,B);
    const ABcm = lenCm(ABpx);

    if(mode === "tri_equil"){
      const ACpx = dist(A,P), BCpx = dist(B,P);
      const ACcm = lenCm(ACpx), BCcm = lenCm(BCpx);
      const hAC = (!lastOk) ? hintToTargetCm(ACcm, ABcm) : "";
      const hBC = (!lastOk) ? hintToTargetCm(BCcm, ABcm) : "";

      ctx.save();
      ctx.lineWidth=4; ctx.strokeStyle="rgba(34,197,94,.70)";
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(P.x,P.y); ctx.lineTo(B.x,B.y); ctx.closePath(); ctx.stroke();
      ctx.restore();

      drawLengthLabel(A,P,"AC = " + fmtCm(ACpx), hAC);
      drawLengthLabel(B,P,"BC = " + fmtCm(BCpx), hBC);
      drawPoint(P,"rgba(37,99,235,.95)", true);

      if(showHelp){
        drawCircle(A,ABpx,true);
        drawCircle(B,ABpx,true);
      }
      return;
    }

    if(mode === "tri_isos"){
      const ACpx = dist(A,P), BCpx = dist(B,P);
      const ACcm = lenCm(ACpx), BCcm = lenCm(BCpx);
      const avg = (ACcm + BCcm)/2;
      const hAC = (!lastOk) ? hintToTargetCm(ACcm, avg) : "";
      const hBC = (!lastOk) ? hintToTargetCm(BCcm, avg) : "";

      ctx.save();
      ctx.lineWidth=4; ctx.strokeStyle="rgba(34,197,94,.70)";
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(P.x,P.y); ctx.lineTo(B.x,B.y); ctx.closePath(); ctx.stroke();
      ctx.restore();

      drawLengthLabel(A,P,"AC = " + fmtCm(ACpx), hAC);
      drawLengthLabel(B,P,"BC = " + fmtCm(BCpx), hBC);
      drawPoint(P,"rgba(37,99,235,.95)", true);
      return;
    }

    if(mode === "tri_right_generic" || mode === "tri_right_talete"){
      ctx.save();
      ctx.lineWidth=4; ctx.strokeStyle="rgba(34,197,94,.70)";
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(P.x,P.y); ctx.lineTo(B.x,B.y); ctx.closePath(); ctx.stroke();
      ctx.restore();

      drawLengthLabel(A,P,"AC = " + fmtCm(dist(A,P)));
      drawLengthLabel(B,P,"BC = " + fmtCm(dist(B,P)));
      drawPoint(P,"rgba(37,99,235,.95)", true);

      if(mode === "tri_right_talete"){
        const M = { x:(A.x+B.x)/2, y:(A.y+B.y)/2 };
        const R = ABpx/2;
        if(showHelp) drawCircle(M,R,true);
      }
      return;
    }

    if(mode === "quad_square" || mode === "quad_rect"){
      const D = { x:A.x, y:P.y };

      ctx.save();
      ctx.lineWidth=4; ctx.strokeStyle="rgba(34,197,94,.70)";
      ctx.beginPath();
      ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.lineTo(P.x,P.y); ctx.lineTo(D.x,D.y);
      ctx.closePath(); ctx.stroke();
      ctx.restore();

      const BCpx = dist(B,P), CDpx = dist(P,D), DApx = dist(D,A);

      if(mode === "quad_square"){
        const BCcm = lenCm(BCpx), CDcm = lenCm(CDpx), DAc = lenCm(DApx);
        const hBC = (!lastOk) ? hintToTargetCm(BCcm, ABcm) : "";
        const hCD = (!lastOk) ? hintToTargetCm(CDcm, ABcm) : "";
        const hDA = (!lastOk) ? hintToTargetCm(DAc,  ABcm) : "";
        drawLengthLabel(B,P,"BC = " + fmtCm(BCpx), hBC);
        drawLengthLabel(P,D,"CD = " + fmtCm(CDpx), hCD);
        drawLengthLabel(D,A,"DA = " + fmtCm(DApx), hDA);
      } else {
        const AB = dist(A,B);
        const CD = dist(P,D);
        const BC = dist(B,P);
        const DA = dist(D,A);
        const hCD = (!lastOk) ? hintToTargetCm(lenCm(CD), lenCm(AB)) : "";
        const hDA = (!lastOk) ? hintToTargetCm(lenCm(DA), lenCm(BC)) : "";
        drawLengthLabel(B,P,"BC = " + fmtCm(BC));
        drawLengthLabel(P,D,"CD = " + fmtCm(CD), hCD);
        drawLengthLabel(D,A,"DA = " + fmtCm(DA), hDA);
      }

      drawPoint(P,"rgba(37,99,235,.95)", true);
      return;
    }
  }

  function check(){
    let ok=false;

    if(mode === "tri_equil"){
      const [I1,I2] = getEquilateralTargets();
      ok = (dist(P,I1)<=TOL) || (dist(P,I2)<=TOL);
      lastOk = ok;
      if(ok){
        setStatus("ok","Bravo! üéâ","Equilatero completato.");
        if(!isCompleted(mode)){ markCompleted(mode); renderMenu(); updateNextButton(); }
      } else setStatus("no","Quasi!","Rendi AC e BC uguali ad AB.");
      return;
    }

    if(mode === "tri_isos"){
      ok = Math.abs(dist(A,P) - dist(B,P)) <= TOL;
      lastOk = ok;
      if(ok){
        setStatus("ok","Bravo! üéâ","Isoscele completato.");
        if(!isCompleted(mode)){ markCompleted(mode); renderMenu(); updateNextButton(); }
      } else setStatus("no","Quasi!","AC e BC devono diventare uguali.");
      return;
    }

    if(mode === "tri_right_generic"){
      const dot = (u,v)=>u.x*v.x+u.y*v.y;
      const vAB={x:B.x-A.x,y:B.y-A.y};
      const vAC={x:P.x-A.x,y:P.y-A.y};
      const vBA={x:A.x-B.x,y:A.y-B.y};
      const vBC={x:P.x-B.x,y:P.y-B.y};
      const vCA={x:A.x-P.x,y:A.y-P.y};
      const vCB={x:B.x-P.x,y:B.y-P.y};
      const eps = 0.06 * (GRID*GRID);
      ok = (Math.abs(dot(vAB,vAC))<=eps) || (Math.abs(dot(vBA,vBC))<=eps) || (Math.abs(dot(vCA,vCB))<=eps);
      lastOk = ok;
      if(ok){
        setStatus("ok","Bravo! üéâ","Triangolo rettangolo completato.");
        if(!isCompleted(mode)){ markCompleted(mode); renderMenu(); updateNextButton(); }
      } else setStatus("no","Quasi!","Prova a fare un angolo di 90¬∞ in A, B o C.");
      return;
    }

    if(mode === "tri_right_talete"){
      const M = { x:(A.x+B.x)/2, y:(A.y+B.y)/2 };
      const R = dist(A,B)/2;
      ok = Math.abs(dist(P,M) - R) <= TOL;
      lastOk = ok;
      if(ok){
        setStatus("ok","Bravo! üéâ","Talete completato.");
        if(!isCompleted(mode)){ markCompleted(mode); renderMenu(); updateNextButton(); }
      } else setStatus("no","Quasi!","C deve stare sul cerchio (AIUTO).");
      return;
    }

    if(mode === "quad_square"){
      const side = dist(A,B);
      const D = { x:A.x, y:P.y };
      const BC = dist(B,P), CD = dist(P,D), DA = dist(D,A);
      ok = (Math.abs(BC-side)<=TOL) && (Math.abs(CD-side)<=TOL) && (Math.abs(DA-side)<=TOL);
      lastOk = ok;
      if(ok){
        setStatus("ok","Bravo! üéâ","Quadrato completato.");
        if(!isCompleted(mode)){ markCompleted(mode); renderMenu(); updateNextButton(); }
      } else setStatus("no","Quasi!","Tutti i lati devono diventare uguali ad AB.");
      return;
    }

    if(mode === "quad_rect"){
      const D = { x:A.x, y:P.y };
      const AB = dist(A,B);
      const CD = dist(P,D);
      const BC = dist(B,P);
      const DA = dist(D,A);
      ok = (Math.abs(AB-CD)<=TOL) && (Math.abs(BC-DA)<=TOL);
      lastOk = ok;
      if(ok){
        setStatus("ok","Bravo! üéâ","Rettangolo completato.");
        if(!isCompleted(mode)){ markCompleted(mode); renderMenu(); updateNextButton(); }
      } else setStatus("no","Quasi!","AB = CD e BC = DA.");
      return;
    }
  }

  let dragging=false;

  function isFreePointMode(){ return (mode === "tri_equil" || mode === "tri_right_talete"); }

  canvas.addEventListener('pointerdown', (e) => {
    if(mode.startsWith("quiz_") || mode === "bonus_free") return;
    const p = pointerPos(e);
    if(hitPoint(P,p.x,p.y)){
      dragging=true;
      canvas.setPointerCapture(e.pointerId);
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const p = pointerPos(e);
    const free = isFreePointMode();
    P.x = snapIfNeeded(clamp(p.x, 20, canvas.width-20), !free);
    P.y = snapIfNeeded(clamp(p.y, 20, canvas.height-20), !free);
    render();
  });

  canvas.addEventListener('pointerup', () => {
    if(!dragging) return;
    dragging=false;

    if(mode === "tri_equil"){
      const [I1,I2] = getEquilateralTargets();
      const MAGNET = 1.6*TOL;
      if(dist(P,I1)<=MAGNET){ P.x=I1.x; P.y=I1.y; }
      else if(dist(P,I2)<=MAGNET){ P.x=I2.x; P.y=I2.y; }
    }

    if(mode === "tri_right_talete"){
      const M = { x:(A.x+B.x)/2, y:(A.y+B.y)/2 };
      const R = dist(A,B)/2;
      const d = dist(P,M);
      const MAGNET = 1.6*TOL;
      if(Math.abs(d-R)<=MAGNET){
        const vx=P.x-M.x, vy=P.y-M.y;
        const L=Math.hypot(vx,vy)||1;
        P.x = M.x + (vx/L)*R;
        P.y = M.y + (vy/L)*R;
      }
    }

    render();
    check();
  });

  function printCertificate(){
    const name = (bonus.name || "").trim();
    document.getElementById("certName").textContent = name ? name : "________________________";
    window.print();
  }

  /* BOTTONI */
  resetBtn.addEventListener('click', () => resetLevel(true));

  helpBtn.addEventListener('click', () => {
    showHelp=!showHelp;
    helpBtn.textContent = showHelp ? "NASCONDI AIUTO" : "AIUTO";
    render();
  });

  nextBtn.addEventListener('click', () => {
    const idx = getIndexById(mode);
    if(idx < LEVELS.length-1){
      const nextId = LEVELS[idx+1].id;
      if(isUnlocked(nextId)) setMode(nextId);
    }
  });

  printBtn.addEventListener('click', () => printCertificate());

  grid1Btn.addEventListener('click', () => { setGridCm(1); resetLevel(true); renderMenu(); updateNextButton(); applyBonusToolbar(mode==="bonus_free"); });
  grid05Btn.addEventListener('click', () => { setGridCm(0.5); resetLevel(true); renderMenu(); updateNextButton(); applyBonusToolbar(mode==="bonus_free"); });

  /* QUIZ UI helpers */

  /* START */
  renderMenu();
  setMode(LEVELS[0].id);
})();
</script>
</body>
</html>
